'use strict'
var path = require('path')
var realpath = require('fs').realpath
var Readable = require('readable-stream').Readable
var readdir = require('readdir-scoped-modules')
var inherits = require('util').inherits

module.exports = ReadModuleTree

module.exports.Module = Module

function Module (name, dir, modulePath, realdir, er) {
  if (this == null) return new Module(dir, modulePath, realdir, er)
  this.name = name
  this.path = dir
  this.realpath = realdir
  this.modulepath = modulePath
  this.isLink = path.resolve(dir) !== realdir
  this.error = er
}

function ReadModuleTree (dir, opts) {
  if (this == null) return new ReadModuleTree(dir, opts)
  Readable.call(this, {objectMode: true})
  this.top = dir
  var pathbits = path.resolve(dir).split(path.sep)
  var name = pathbits.pop()
  var parentname = pathbits.pop()
  if (parentname && parentname[0] === '@') name = parentname + '/' + name
  this.queue = [{action: this.readModulePath, args: [{}, name, dir, '/']}]
  this.moduleClass = (opts && opts.moduleClass) || Module
  this.paused = true
}
inherits(ReadModuleTree, Readable)

ReadModuleTree.prototype._read = function () {
  if (!this.paused) return
  this.paused = false
  var self = this
  return dequeueNext()

  function dequeueNext () {
    var todo = self.queue[0]
    todo.action.apply(self, todo.args.concat(function (err, keepProcessing) {
      if (err) {
        self.emit('error', err)
        return
      }
      self.queue.shift()
      if (!self.queue.length) return self.push(null)
      if (keepProcessing != null && !keepProcessing) {
        self.paused = true
        return
      }
      dequeueNext()
    }))
  }
}

ReadModuleTree.prototype.readModulePath = function (seen, name, dir, modulePath, cb) {
  var self = this
  realpath(dir, function (er, realdir) {
    self.queue.push({
      action: self.readModule,
      stack: (new Error()).stack,
      args: [seen, name, dir, modulePath, realdir, er]
    })
    cb()
  })
}

ReadModuleTree.prototype.readModule = function (seen, name, dir, modulePath, realdir, realdirEr, cb) {
  if (seen[realdir]) {
    realdirEr = new Error('Cycle detected, ' + seen[realdir] + ' and ' + dir + ' point to ' + realdir)
    realdirEr.code = 'EMODULECYCLE'
    realdirEr.sources = [seen[realdir], dir]
    realdirEr.destination = realdir
  } else {
    seen = Object.create(seen)
    seen[realdir] = dir
  }
  var mod = new this.moduleClass(name, dir, modulePath, realdir, realdirEr)
  if (!realdirEr && !mod.isLink) this.queue.push({action: this.readDir, args: [seen, dir, modulePath]})
  cb(null, this.push(mod))
}

ReadModuleTree.prototype.readDir = function (seen, dir, modulePath, cb) {
  var self = this
  readdir(path.join(dir, 'node_modules'), function (er, files) {
    if (!files) return cb()
    files.forEach(function (file) {
      self.queue.push({action: self.readModulePath, args: [
        seen, file, path.join(dir, 'node_modules', file), path.join(modulePath, file)]})
    })
    cb()
  })
}
